#include <reg51.h>
#define uchar unsigned char
#define uint unsigned int
sfr P1ASF = 0X9D;
sfr ADC_CONTR=0XBC;
sfr ADC_RES=0XBD;
sfr ADC_RESL=0XBE;
sfr AUXR1=0XA2;
sbit D7=P0^7;
sbit rs=P2^0;
sbit rw=P2^1;
sbit en=P2^2;
sbit psb=P2^3;
sbit GD = P1^7;
sbit VD = P3^4;
sbit VI = P3^6;
sbit TD = P3^7;
sbit TE = P3^5;
sbit clock = P1^0;
uint pdata a[128];
uchar code biaoge[]={
0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0x00,0x08,0x00,0x00,0x80,0x00,0x08,0x00,0x00,0x80,0x00,0x08,0x00,0x00,
0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x3E,0xF3,0xE7,0x00,0x00,0x11,0x7C,0x01,0xE0,0x78,0x00,0x00,0x04,0x40,0x00,0x00,
0x20,0x8A,0x08,0xB0,0x00,0x11,0x0C,0x01,0x10,0x44,0xC0,0x00,0x04,0x40,0x00,0x00,
0x20,0x8A,0x08,0xB0,0x00,0x11,0x18,0x01,0x10,0x44,0xC0,0x00,0x04,0x40,0x00,0x00,
0x3E,0xF3,0xE8,0x80,0x00,0x1F,0x30,0x01,0xE0,0x78,0x00,0x00,0x04,0x40,0x00,0x00,
0x20,0xC2,0x08,0xB0,0x00,0x11,0x30,0x01,0x0F,0x40,0x00,0x00,0x04,0x40,0x00,0x00,
0x20,0xA2,0x0B,0xB0,0x00,0x11,0x60,0x01,0x00,0x40,0xC0,0x00,0x06,0xC0,0x00,0x00,
0x20,0x92,0x09,0x80,0x00,0x11,0x60,0x01,0x00,0x40,0xC0,0x00,0x03,0x80,0x00,0x00,
0x20,0x8B,0xE7,0xC0,0x00,0x11,0x7C,0x01,0x00,0x40,0x00,0x00,0x01,0x00,0x00,0x00};
uchar heng,zong;
uchar num_5ms;
uchar freq1,volt1,freq;
void delay(uint t)//延时2*1*t+5us
{
	while(t--);
}
void delay1ms(uint t) //1ms
{
	uint i,j;
	i=0;
	for(i=0;i<t;i++)
		for(j=0;j<64;j++);	
}
bit lcd_busy()//判断数据口是否忙绿
{
	bit result;
	D7 = 1;
	rs = 0;
	rw = 1;
	en = 0;
	delay(50);
	result = D7;
	en = 0;
	return(result);
}
void lcd_wcmd(uchar wcmd)//写命令
{
	while(~lcd_busy());
	rs=0;
	rw=0;
	en=0;
	P0=wcmd;
	delay1ms(5);
	en=1;
	delay1ms(5);
	en=0;
}
void lcd_wdat(uchar dat)//写数据
{
	while(~lcd_busy());
	rs=1;
	rw=0;
	en=0;
	P0=dat;
	delay1ms(5);
	en=1;
	delay1ms(5);
	en=0;
}
uchar lcd_rdat(void)//读数据
{
	uchar rdat;
	while(!lcd_busy());
	P0=0xff;
	rs=1;
	rw=1;
	en=0;
	en=1;
	rdat=P0;
	delay(50);
	en=0;
	return rdat;
}
//void showgroup(uchar x,uchar y,uchar *p)//选择在哪一行写数据
//{
//	switch(y)
//	{
//		case 1:lcd_wcmd(0x80+x-1);break;
//		case 2:lcd_wcmd(0x90+x-1);break;
//		case 3:lcd_wcmd(0x88+x-1);break;
//		case 4:lcd_wcmd(0x98+x-1);break;
//	}
//	while(*p)
//	{
//		lcd_wdat(*p++);
//	}
//}
void lcd_init()
{
	psb=1;
	lcd_wcmd(0x30);//基本指令集
	delay1ms(5);
	lcd_wcmd(0x0c);
	delay1ms(5);
	lcd_wcmd(0x01);
	delay1ms(5);
	lcd_wcmd(0x06);
	delay1ms(5);
}
void clear_screen()//清GDRAM
{
	uchar i,j,k;
	lcd_wcmd(0x34);//关闭绘图显示功能
	i=0x80;
	for(j=0;j<32;j++)
	{
		lcd_wcmd(i++);//纵坐标Y加一
		lcd_wcmd(0x80);//横坐标
		for(k=0;k<16;k++)
		{
			lcd_wdat(0x00);//给某一行清零
		}
	}
	i=0x80;
	for(j=0;j<32;j++)
	{
		lcd_wcmd(i++);
		lcd_wcmd(0x88);
		for(k=0;k<16;k++)
		{
			lcd_wdat(0x00);
		}
	}
	lcd_wcmd(0x36);
	lcd_wcmd(0x30);
}
void draw_pic(uchar *pic)
{
	uchar i,j,k;
	lcd_wcmd(0x34);
	i=0x80;
	for(j=0;j<32;j++)
	{
		lcd_wcmd(i++);
		lcd_wcmd(0x80);
		for(k=0;k<16;k++)
		{
			lcd_wdat(*pic);
			pic++;
		}
	}
	i=0x80;
	for(j=0;j<32;j++)
	{
		lcd_wcmd(i++);
		lcd_wcmd(0x88);
		for(k=0;k<16;k++)
		{
			lcd_wdat(*pic);
			pic++;
		}
	}
	lcd_wcmd(0x36);
	lcd_wcmd(0x30);
}
void draw_point(uchar x,uchar y)
{
	uchar readh,readl,row,tier,tier_b;
	lcd_wcmd(0x34);
	lcd_wcmd(0x36);
	tier=x>>4;
	tier_b=x&0x0f;
	if(y<32)
	{
		row=y;
	}
	else
	{
		row=y-32;
		tier+=8;
	}
	lcd_wcmd(row+0x80);
	lcd_wcmd(tier+0x80);
	lcd_rdat();
	readh=lcd_rdat();
	readl=lcd_rdat();
	lcd_wcmd(row+0x80);
	lcd_wcmd(tier+0x80);
	if(tier_b<8)
	{
		readh|=(0x01<<(7-tier_b));
		
	}
 	else
	{
		readl|=(0x01<<(15-tier_b));	
	}
	lcd_wdat(readh);
	lcd_wdat(readl);

	lcd_wcmd(0x30);	
}
void draw_0(uchar x,uchar y)	  //?0
{	 
	uchar i;
	for(i=0;i<3;i++)
	{
	draw_point(x+i,y);
	draw_point(x+i,y+4);
	}
	for(i=0;i<4;i++)
	{
	draw_point(x,y+1+i);
	draw_point(x+2,y+1+i);
	}
}
void draw_1(uchar x,uchar y)
{
	uchar i;
	for(i=0;i<5;i++)
	 draw_point(x+1 ,y+i);
}
void draw_2(uchar x,uchar y)
{
	uchar i;
	for(i=0;i<3;i++)
	{
	 	draw_point(x+i,y);
		draw_point(x+i,y+4);
		draw_point(x+2-i,y+1+i);
	}
}
void draw_3(uchar x,uchar y)
{
	 uchar i;
	for(i=0;i<3;i++)
	{
	 	draw_point(x+i,y);
		draw_point(x+i,y+2);
		draw_point(x+i,y+4);
	}
   draw_point(x+2,y+1);
	draw_point(x+2,y+3);
}
void draw_4(uchar x,uchar y)
{
	uchar i;
	for(i=0;i<2;i++)
		{
			draw_point(x,y+1+i);
		}
	for(i=0;i<5;i++)
		{
			draw_point(x+1,y+i);
		
		}	  
	draw_point(x+2,y+2);	
}
void draw_5(uchar x,uchar y)
{
	uchar i;
	for(i=0;i<3;i++)
	{
	 	draw_point(x+i,y);
		draw_point(x+i,y+2);
		draw_point(x+i,y+4);
	}
    draw_point(x,y+1);
	draw_point(x+2,y+3);

}
void draw_6(uchar x,uchar y)
{
	uchar i;
	for(i=0;i<3;i++)
	{
	 	draw_point(x+i,y);
		draw_point(x+i,y+2);
		draw_point(x+i,y+4);
	}
   draw_point(x,y+1);
	draw_point(x+2,y+3);
	draw_point(x,y+3);
}
void draw_7(uchar x,uchar y)
{	
	uchar i;
	for(i=0;i<3;i++)
	{
	 	draw_point(x+i,y);
	}
	for(i=0;i<4;i++)
	{
	 	draw_point(x+2,y+1+i);
	}	
}
void draw_8(uchar x,uchar y)
{
	uchar i;
	for(i=0;i<5;i++)
	{
	 	draw_point(x,y+i);
		draw_point(x+2,y+i);
	}
		draw_point(x+1,y);
		draw_point(x+1,y+2);
		draw_point(x+1,y+4);
}
void draw_9(uchar x,uchar y)
{
	uchar i;
	for(i=0;i<3;i++)
	{
	 	draw_point(x,y+i);
		draw_point(x+2,y+i);
	}
	for(i=0;i<2;i++)
	{
	 	draw_point(x+1,y+2*i);
		draw_point(x+2,y+i+3);
	}
}
void number(uchar x,uchar y,uchar i)
{	
	switch(i)
	{
		case 0:draw_0(x,y);break;
		case 1:draw_1(x,y);break;
		case 2:draw_2(x,y);break;
		case 3:draw_3(x,y);break;
		case 4:draw_4(x,y);break;
		case 5:draw_5(x,y);break;
		case 6:draw_6(x,y);break;
		case 7:draw_7(x,y);break;
		case 8:draw_8(x,y);break;
		case 9:draw_9(x,y);break;					
	}
}
void draw_biaotemp(uchar heng_1,uchar zong_1)
{
	

	lcd_wcmd(0x01);
	delay1ms(10);			
	draw_point(93,63);
	if(2*heng_1<10)
		number(27,50,2*heng_1);
	else
		{
		 number(27,50,2*heng_1/10);
		 number(32,50,2*heng_1%10);
		}
	if(4*heng_1<10)
		number(47,50,4*heng_1);
	else
		{
		 number(47,50,4*heng_1/10);
		 number(52,50,4*heng_1%10);
		}
	if(6*heng_1<10)
		number(67,50,6*heng_1);
	else
		{
		 number(67,50,6*heng_1/10);
		 number(72,50,6*heng_1%10);
		}
	if(8*heng_1<10)
		number(87,50,8*heng_1);
	else
		{
		 number(87,50,8*heng_1/10);
		 number(92,50,8*heng_1%10);
		}
	number(107,50,10*heng_1/10);
	number(112,50,10*heng_1%10);
	if(2*zong_1<10)
			number(4,0,2*zong_1);
		else
			{
			 number(0,0,2*zong_1/10);
			 number(4,0,2*zong_1%10);
			}		
	number(4,22,zong_1);
	number(4,44,0);
	//number(0,0,1);
	draw_0(95,58);					
delay1ms(3);
}
void draw_temp(uchar freq,uchar volt)
{
	lcd_wcmd(0x01);
	delay1ms(10);
	if(freq<10)
		number(35,58,freq);
	else
		{
		 number(31,58,2*freq/10);
		 number(35,58,2*freq%10);
		}
		if(volt<10)
		number(89,58,volt);
	else
		{
		 number(85,58,volt/10);
		 number(89,58,volt%10);
		}
}
uchar key_pcn()
{
	uint key_num;
	if(GD==0)
	{
		delay1ms(10);
		if(GD==0)
		{		
			while(!GD);
			key_num = 1;
		}
	}
	if(VD==0)
	{
		delay1ms(10);
		if(VD==0)
		{			
			while(!VD);
			key_num = 2;
		}
	}
	if(VI==0)
	{
		delay1ms(10);
		if(VI==0)
		{		
			while(!VI);
			key_num = 3;
		}
	}
	if(TD==0)
	{
		delay1ms(10);
		if(TD==0)
		{
			while(!TD);
			key_num = 4;
		}
	}
	if(TE==0)
	{
		delay1ms(10);
		if(TE==0)
		{	
			while(!TE);
			key_num = 5;
		}
	}
	return key_num;
}
void key_process()
{
	uchar key;	
	key=key_pcn();
	switch(key)
	{
		case 1:break;
		case 2:clear_screen();
			delay1ms(3);
			draw_pic(biaoge);
			zong++;
			if(zong==6)
				zong=0;
			break;
		case 3:clear_screen();
			delay1ms(3);
			draw_pic(biaoge);
			zong--;
			if(zong==0)
				zong=1;
			break;
		case 4:clear_screen();
			delay1ms(3);
			draw_pic(biaoge);
			heng++;
			if(heng==10)
				heng = 0;
			break;
		case 5:clear_screen();
			delay1ms(3);
			draw_pic(biaoge);
			heng--;
			if(heng==0)
				heng=9;
			break;
	}	
	
	draw_biaotemp(heng,zong);
}
void adc_init()
{
	P1ASF =0x02;//用通道1
	AUXR1 = 0x04;//高位放在ADC_RES中，低8位放在ADC_RESL中
	//ADC_CONTR|=0x01;//确定通道1
	//ADC_CONTR&=0x9f;//转换速度,46.7Khz
	//ADC_CONTR|=0X80;//开启电源
	ADC_CONTR=0X81;
	delay(10);
}
uint get_adcresult()
{
	uchar ad_finish=0;
	uint temp;
	uchar result;
	ADC_RES=0X00;
	ADC_RESL=0X00;
	ADC_CONTR|=0X08;//启动转换
	while(ad_finish==0)
	{
	ad_finish=ADC_CONTR&0x10;
	}
	ADC_CONTR&=0xef;
	delay(1);
	temp=ADC_RES;
	//result=temp*5/256//模拟8位AD转换
	temp=ADC_RES*256+ADC_RESL;
	result=temp*5/1024;
	return result;
}
void adc_process()
{
	uchar i,y_temp;
	for(i=0;i++;i<128)
	{
		a[i]=get_adcresult();	
		y_temp=a[i]/0.078;//5v,64格。每格0.078V
			draw_point(i+11,48-y_temp);
	}
	volt1=y_temp*0.078;
	ADC_CONTR&=0Xf7;//关闭转换
	ADC_CONTR&=0X7f;//关闭电源
}
void main()
{
	TMOD=0X11;
	TH0=(65535-50000)/256;
	TL0=(65535-50000)%256;//20hz
	TH1=(65535-50000)/256;
	TL1=(65535-50000)%256;
	ET1=1;
	TR1=1;
	EX1=1;//开启外部定时器
	IT1=1;//跳变沿开启中断
	ET0=1;
	TR0=1;
	EA=1;
	freq=0;
	clock=1;
	heng=1;
	zong=1;
	adc_init();
	lcd_init();
	
	while(1)
	{	
		clear_screen();
		delay1ms(3);
		draw_pic(biaoge);
		key_process();
		adc_process();
		draw_temp(freq1,volt1);
		delay1ms(50000);
	}
}
void time_T0() interrupt 1
{
	TH1=(65535-50000)/256;
	TL1=(65535-50000)%256;
	num_5ms++;
	if(num_5ms==20)
	{
		freq1=freq;
	   freq=0;
	}
}
void time_INT1() interrupt 2//外部中断一
{
	freq++;
}
void time_T1() interrupt 3//产生方波
{
	TH1=(65535-50000)/256;
	TL1=(65535-50000)%256;
	clock=~clock;
}