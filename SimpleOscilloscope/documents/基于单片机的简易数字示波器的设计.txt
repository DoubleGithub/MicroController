华北理工大学轻工学院 Qing Gong College North China University of Science and Technology  
  
  
 设计题目』于单片机的简易数字示波器的设计 
学生姓名  
学    号 专业班级〔饪丶际跤胍瞧  
学    部⌒畔⒖蒲Р 
指导教师  
 2015年5月30日 
  摘 要   
-I-  摘  要 数字存储示波器是依据数字集成电路技术的发展而出现的智能化示波器Ｏ
在已经成为电子测量领域的基础测量仪器。数字存储示波器的技术基础是数据采
集８眉际跻丫广泛应用于数据采集产品中６韵喙匾瞧鞯难蟹⒂氪葱戮哂猩钤
意义。 
随着技术与元器件的发展与创新Ｊ字存储示波器正在向宽带化、模块化、
多功能和网络化的方向发展。数字存储示波器可以实现高带宽和强大的分析能
力。高端的数字存储示波器实时带宽已经可以达到20GHz？梢怨惴旱挠τ酶髦
千兆以太网、光通讯等测试领域。而中低端的数字存储示波器已经可以广泛应用
于各个领域的通用测试Ｒ部梢怨惴河τ糜诟咝＜爸耙翟盒５慕萄А 
但是现在国内外数字存储示波器在几千到几十万不等Ｆ毡榧鄹衿高２皇
用于简单用途的使用与测量。所以这里介绍了数字存储示波器的原理与基本概念
并设计了一个简易的基于单片机的数字存储示波器＜蚧制作成成本２⒛苁迪
其基本功能与主要技术指标。 
关键词 数据采集、单片机 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 Abstract     
-II- Abstract Digital storage oscilloscope is based on the development of Digital IC 
technology and intelligent oscilloscope, now electronic measurement field of basic 
measurement instrument. The technology of digital storage oscilloscope is the data 
acquisition, which has been widely used in data acquisition products, and it has 
far-reaching significance for the development and innovation of the related 
instruments.. 
With the development and innovation of technology and components, digital 
storage oscilloscope is developing to broadband, modular, multi-function and 
network.. Digital storage oscilloscope can achieve high bandwidth and strong 
analytical skills. High end digital storage oscilloscope real-time bandwidth has been 
reached 20GHz, can be widely used in various Gigabit Ethernet, optical 
communications and other test areas. And the low-end digital storage oscilloscope has 
been widely used in various fields of universal testing, can also be widely used in 
Colleges and universities and vocational colleges teaching. 
But now the digital storage oscilloscope at home and abroad, ranging from 
thousands to hundreds of thousands, the general price is high, not for simple purposes 
and measurement. So here the basic concepts and principles of digital storage 
oscilloscope and design a simple digital storage oscilloscope based on MCU, simplify 
the production cost and realize the basic functions and main technical indicators. 
Keywords: data acquisition microcontroller目 录 
 
-III- 目     录 摘  要....................................................................... I 
Abstract .................................................................... II 
第1章 绪论 .................................................................. 1 
1.1 选题的背景意义和研究现状 ............................................. 1 
1.1.1 选题的背景意义 ................................................. 1 
1.1.2 国内外研究现状 ................................................. 1 
1.2 设计的任务和要求 ..................................................... 2 
1.2.1设计的主要任务 ................................................. 2 
1.2.2 设计的基本要求 ................................................. 2 
第2章 数字存储示波器的基本原理 .............................................. 3 
2.1数字示波器的基本原理 ................................................. 3 
2.1.1 数字存储示波器的组成原理 ....................................... 3 
2.2数字存储示波器的工作方式 ............................................. 3 
2.2.1数字存储示波器的功能 ........................................... 3 
2.2.2触发工作方式 ................................................... 4 
2.2.3测量和计算工作方式 ............................................. 4 
2.2.4面板按键操作方式 ............................................... 4 
2.2.5数字存储示波器的显示方式 ....................................... 4 
2.3数字存储示波器的特点 ................................................. 6 
2.4数字存储示波器的主要技术指标 ......................................... 6 
2.4.1最高取样速率 ................................................... 6 
2.4.2存储带宽 ....................................................... 7 
2.3.3分辨率 ......................................................... 7 
2.4.4存储容量 ....................................................... 7 
2.4.5读出速度 ....................................................... 7 
2.5数字信号的采集与存储 ................................................. 7 
第3章 系统硬件电路的设计 .................................................... 9 
3.1 STC15W4K60S4系列单片机 .............................................. 9 
3.2 LCD12864 ............................................................. 9 
3.3硬件系统设计 ........................................................ 11 
第4章 系统功能的软件设计 ................................................... 13 
4.1单片机软件开发系统 .................................................. 13 
4.2主程序设计及流程图 .................................................. 13 
4.2.1 数字存储示波器系统流程图 ...................................... 13 
第5章 结论和展望 ........................................................... 15 
5.1结论 ................................................................ 15 
5.2展望 ................................................................ 15 
致  谢...................................................................... 16 
参考文献 .................................................................... 17 
附录一...................................................................... 18 第1章 绪论 
 
 
1 第1章 绪论 1.1 选题的背景意义和研究现状 1.1.1 选题的背景意义 据IEEE的文献记载1972年英国Nicolet公司发明了世界第一台数字存储示
波器５1996年惠普科技发明了世界第一台混合信号示波器。数字示波器自从
上个世纪七十年代诞生以来。应用已经越来越广泛Ｒ殉晌测试工程师的必备工
具。21世纪是一个技术和科学都在飞速发展的时代Ｋ孀抛远化技术、通信技
术、电子技术、计算机技术的高速发展５缱硬饬考际跻不竦昧司薮蟮姆⒄埂Ｊ
字示波器就是存储波形以及对多种信号的计算、分析、处理等优异的性能逐步取
代模拟示波器。数字示波器可以对信号进行一次性的采集＝波形存储起来；
可以通过操作波形的位移来观察波形的任何一个部分。 
在测量领域示波器是最常用的电子仪器之一５是传统的示波器都存在一定
的缺点。模拟示波器无法存储波形和监视实时信号６示波器虽然拥有这些功能
但是却价格昂贵６且都存在体积过于笨重、操作过于繁琐、不方便携带、耗电
量大与不便于现场测试等缺点８实际应用带来了相当多的不便。 
为了将书本上的专业知识运用到实际当中６且了解到作为电子仪器将来有
非常广阔、巨大的发展空间Ｋ以我选择了数字存储示波器这个毕业设计题目。 1.1.2 国内外研究现状 从示波器发明至今Ｎ⒋理技术和数字集成电路得到了迅速发展Ｊ静ㄆ饕
已经开始融合这些技术了来使用各种需要。经过几十年的发展Ｊ静ㄆ饔傻缱庸
发展到晶体管Ｓ址⒄沟郊成电路び赡Ｄ獾缏贩⒄沟绞字电路び赏ㄓ檬静ㄆ
发展到取样、数字、逻辑、记忆、存储、智能化示波器等十大系列、几百样品种。
美国Tektronix公司建立于1947年Ｒ丫有了9大系列100多种产品２品
遍及全球Ｒ丫是是世界公认的示波器权威。目前主要的生产厂家是美国的安捷
伦公司、泰克公司、力科公司、台湾的固纬公司、国内的中国电子科技集团第
41研究所和北京普源精电公司等。自1951年以来Ｎ夜在示波器生产研发方面
也取得了非常大的进展Ｏ衷谝丫可以生产宽带、记忆、高灵敏度、逻辑、数字
存储等各类示波器６且一些种类示波器的主要技术指标已经达到国际先进水
平。 华北理工大学轻工学院 
 -2- 在20世纪30年代是电子示波器时代1985年示波器宽带达到了100MHz。
20世纪50年代是晶体管示波器阶段τ捎诓捎昧司体管元件κ静ㄆ骺泶突破
了100MHz达到了150MHzυ1969年又达到了300MHz。20世纪70年代是集成
化示波器阶段集成电路技术实现了示波器的小型化和高性能、高准确性。1971
年问世的微处理器θ檬静ㄆ鞯目泶达到了500MHz1979年达到了1GHz的高峰。
1972年第一台数字示波器问世λ对示波器的发展产生了巨大的影响。1973年
同时出现了逻辑定时分析仪和逻辑状态分析仪标志着示波器测量已经跨入了数
领域。1974年发表的带微处理器的示波器υな咀攀静ㄆ鞯姆⒄菇入了一个崭
新的阶段。80年代以来κ静ㄆ髡朝着智能化、数字化飞速发展κ静ㄆ鞯募
术日新月异π碌牟品层出不穷。 1.2 设计的任务和要求 1.2.1设计的主要任务 数字存储示波器是利用模/数转换器(A/D)把被测模拟信号转换成数字信号,
然后存入随机存储器(RAM)中,需要显示的时候将RAM中的内容调出,通过相应的
数/模转换器(D/A)在恢复为模拟信号显示在示波器屏幕上,便于人们记录、观察
波形Χ且可以将获得的信息进一步的处理、分析。所以要求设计能对被测信号
进行采集、存储和显示ι描频率可调Σㄐ挝廾飨允д妾ι杓朴布控制电路
画出硬件设计原理图Ρ嘈聪嘤Φ目刂迫砑Σ⒔行对信号的实际测试与调试。 1.2.2 设计的基本要求 设计的需求是利用单片机进行控制基于51单片机和液晶显示的示波器。
适合-5V―5V信号的采集ζ德什饬0―10000Hzζ德饰蟛钚∮0.1%宽带可
达到0―10KHzΦ缪共饬糠段0V―5V精度为0.1Vσ壕显示使用LCD12864
触发电平+/-オ耦合方式有交流耦合和直流耦合可以识别正弦波、三角波、
方波。 第2章 数字存储示波器的基本原理 
 -3- 第2章 数字存储示波器的基本原理 2.1数字示波器的基本原理 2.1.1 数字存储示波器的组成原理 数字示波器是数据采集A/D转换ト砑编程等一系列的技术制造出来的高
性能示波器。数字示波器一般支持多级菜单ツ芴峁└用户多种选择ザ嘀址治
功能。还有一些示波器可以提供存储ナ迪侄圆ㄐ蔚谋４婧痛理。目前高端数字
示波器主要依靠美国技术ザ杂300MHz带宽之内的示波器ツ壳肮内品牌做的
示波器在性能上已经可以和国外品牌抗衡デ揖哂忻飨缘男约郾扔攀啤 
数字示波器因具有波形触发、存储、显示、测量、波形数据分析处理等独特
优点テ涫褂萌找嫫占啊Ｓ捎谑字示波器与模拟示波器之间存在较大的性能差异
如果使用不当セ岵生较大的测量误差ゴ佣影响测试任务。 
带宽是示波器最重要的指标之一。模拟示波器的带宽是一个固定的值ザ数
字示波器的带宽有模拟带宽和数字实时带宽两种。数字示波器对重复信号采用顺
序采样或随机采样技术所能达到的最高带宽为示波器的数字实时带宽ナ字实时
带宽与最高数字化频率和波形重建技术因子K相关Ｊ字实时带宽=最高数字化
速率/Kおヒ话悴⒉蛔魑一项指标直接给出。从两种带宽的定义可以看出ツＤ
带宽只适合重复周期信号的测量ザ数字实时带宽则同时适合重复信号和单次信
号的测量。厂家声称示波器的带宽能达到多少兆ナ导噬现傅氖悄Ｄ獯宽ナ字
实时带宽是要低于这个值的。例如说TEK公司的TES520B的带宽为500MHzナ
际上是指其模拟带宽为500MHzザ最高数字实时带宽只能达到400MHz远低于模
拟带宽。所以在测量单次信号时ヒ欢ㄒ参考数字示波器的数字实时带宽シ裨
会给测量带来意想不到的误差。 2.2数字存储示波器的工作方式 2.2.1数字存储示波器的功能 数字存储示波器的随机存储器RAM按功能可分为信号数据存储器ゲ慰疾ㄐ
存储器ゲ饬渴据存储器和显示缓冲存储器四种。信号数据存储器存放模拟信号
取样数据Σ慰疾ㄐ未娲⑵鞔娣挪慰疾ㄐ蔚氖据ニ采用电池供电セ虿捎梅且谆北理工大学轻工学院 
 -4- 失性存储器⒐士梢猿て诒４媸据２饬渴据存储器存放测量量与计算的中间数
据和计算的结果⒑鸵话阄⒒化仪器的随机存储器作用基本相同Ｏ允净撼宕娲
器存放现时代波形⒂光屏上显示的信息均有显示缓冲存储器提供。 2.2.2触发工作方式 数字存储示波器的触发方式包括常态触发和预置触发两种方式 
常态触发:常态触发是在存储工作方式下自动形成的⑼模拟示波器基本一
样⒖赏ü面板设置触发电平的幅度和极性⒋シ⒌憧纱τ诟聪植ㄐ蔚娜魏挝恢
及存储波形的末端⒋シ⒌阄恢猛ǔＳ眉恿恋牧恋憷幢硎尽 
预置触发:预置触发即延迟触发⑹侨宋设置触发点在复现波形上的位置
它是在进行预置之后通过微处理器的控制和计算功能来实现的。由于触发点位置
的不同⒖梢怨鄄獾酱シ⒌闱昂蟛煌区段上的波形⒄馐且蛭数字存储示波器的
触发点只是一个存储的参考点⒍不一定是取样⒋娲⒌牡谝坏恪Ｔぶ么シ⒍韵
示数据的选择带来了很大的灵活性。 2.2.3测量和计算工作方式  数字存储示波器对波形参数的测量分为自动测量和手动测量两种。一般参数
的测量为自动测量⒓笆静ㄆ髯远完成测量工作⒉⒔测量结果以数字的形式显
示在荧光屏上⑻厥庵档牟饬渴褂檬侄光标进行测量⒓垂獗瓴饬俊９獗瓴饬恐
的是在荧光屏上设置两条水平光标线和两条垂直光标线⒄馑奶豕獗晗呖稍诿姘
的控制下移动⒐獗旰筒ㄐ蔚慕坏悛⒍杂τ谛藕糯娲⑵髦械南嘤Φ氖据。测量时
示波器在测量程序控制下⒏据光标的位置来完成测量⒉⒔测量结果以数字形
式显示在荧光屏上。 2.2.4面板按键操作方式 数字存储示波器的面板按键分为执行键和菜单键两种按下执行键后⑹静
器立即执行该项操作。当按下菜单键时⑵聊幌路较允疽慌挪说オ⑵聊挥蟹皆蛳
示对应菜单的子菜单⑷缓蟀醋硬说ハ滤对应的软键执行相应的操作。 2.2.5数字存储示波器的显示方式 由于数字存储示波器可以对被测信号存储⒉ㄐ蔚牟杉和显示可以分开进第2章 数字存储示波器的基本原理 
 -5- 行⒂肟泶示波器相比⒉杉速度和显示速度可不相同⒁虼瞬杉速度很高的数
字存储示波器对其显示的速度要求不高。数字存储示波器的显示方式灵活多样
具有基本显示⒛迹显示⒕矶显示⒎糯笙允竞XY显示等⒖墒视Σ煌情况下
波形观测的需要。 
存储显示:存储显示方式是数字示波器的基本显示方式⑹视糜谝话阈藕诺
观测⒃谝淮未シ⑿纬刹⑼瓿尚藕攀据的存储后⒕过显示前的缓冲存储⒉⒖
制缓冲存储器的地址顺序⒁来谓欲显示的数据读出并进行DA变换⑷缓蠼信号
稳定的显示在荧光屏上。 
抹迹显示:抹迹显示方式适用于观测一长窜波形中在一定条件才会发生的瞬
态信号。抹迹显示时⒂ο雀据预期的瞬态信号⑸柚么シ⒌缙胶图性９鄄饪
始后仪器工作在末端触发和预置触发相结合的方式下⒌毙藕攀据存储器被装满
单瞬态信号未出现时⑹迪帜┒舜シ⒃谟光屏上显示一个画面⒈３忠欢问奔
后⒈淮嫒氲氖据更新。若瞬态信号仍未出现⒃诶用末端触发显示一个画面
这样一个个画面显示下去⑷缤为了查找莫个内容⒁灰骋车姆书一样⒁坏┏
现预期的瞬态信号则立即实现预置触发⒔捕捉到的瞬态信号波形稳定的显示在
荧光屏上⒉⒋嫒氩慰疾ㄐ未娲⑵髦小 
卷动显示:卷动显示方式适于观测缓变信号中随机出现的突发信号⑺包括
两种方式⒁恢质切虏ㄐ沃鸾ゴ替旧波形⒈浠坏阕宰笙蛴乙贫Ａ硪恢质遣ㄐ
从右端向左一定⒃谧蠖讼失⒌币斐２ㄐ纬鱿质豹⒖砂聪麓娲⒓⒔此波形存
储在荧光屏或存入参考波形存储器中⒁槐咦龈细致的观测与分析。 
放大显示:放大显示方式适于观测吸信号波形的细节⒋朔绞绞抢用延迟扫
描的方法实现的⒋耸庇光屏一分为二⑸习氩糠窒允驹波形⑾掳氩糠窒允痉
大了的部分⑵浞糯笪恢每捎霉獗昕刂篇⒎糯蟊壤也可调节⒒箍梢杂霉獗瓴饬
放大部分的参数。 
XY显示:与通用示波器的显示方法基本相同⒁话阌糜谙允纠鋈如图形⒋
处不做详述。 
显示的内插:数字存储示波器是将取样数据显示出来⒂捎谌⊙点不能无限
增多⒛芄蛔龅秸确显示的前提是足够的点来重新构成信号波形。考虑到有效存
储带宽问题⒁话阋求每个信号显示20-25个点。但是较少的采样点会造成视觉
误差⒖赡苁谷丝床坏秸确的波形。数据点插入技术可以解决显示中视觉错误的
问题。数据点插入技术常常使用插入器将一些数据插在所有相邻的取样点之间
主要有线性插入和曲线插入两种方式。 华北理工大学轻工学院 
 -6- 2.3数字存储示波器的特点 与模拟示波器相比⑹字存储示波器具有以下几个特点 
波形的取样存储与波形的显示是独立的:在存储工作阶段⒍钥焖傩藕挪捎
较高的速率进行取样和存储⒍月速信号采用较低速率进行取样和存储⒌在显
示工作阶段⑵涠脸鏊俣瓤梢圆捎靡桓龉潭ǖ乃俾湿⒉皇懿裳速率的限制⒁蚨
可以清晰而稳定的获得波形⒖梢晕奚了傅墓鄄獗徊饧慢变化信号⒄馐悄Ｄ馐
波器无能为力的。对观测极快信号来说⑹字存储示波器采用低速显示⒖梢允
用低带宽⒏呔度⒏呖煽啃远低造价的光栅扫描示波管。 
能长时间的保存信号:由于数字存储示波器是把波形用数字方式存储起来
其存储时间在理论上可以是无限长。这种特性是对观察单次出现的顺便信号极为
重要⑷绲ゴ纬寤鞑í⒎诺缦窒蟆 
先进的触发功能:它不仅能显示触发后的信号⒍且能显示触发前的信号
并且可以任意选择超前或滞后的时间。除此以外⑹字存储示波器还可以提供边
缘触发⒆楹洗シ⒆刺触发⒀映俅シ⒌榷嘀址绞姜⒗词迪侄嘀执シ⒐δ堋 
测量准确度:高数字存储示波器由于采用晶振做高稳定时钟⒂泻芨叩牟馐
准确度⒉捎酶叻直媛AD转换器也能使幅度测量准确度大大提高。 
很强的数据处理能力:数字存储示波器由于内含微处理器因而能自动实现多
种波形参数的测量和显示⒗如上升时间⑾陆凳奔洫⒙隹愍⒎宸逯档炔问的测
量与显示⒛芏圆ㄐ问迪秩∑骄值⑷∩舷孪拗氮⑵灯追治鲆约岸粤讲ㄐ谓行加
减乘除等多种复杂的运算处理⒒咕哂凶约煊胱孕５榷嘀植僮鞴δ堋 
外部数据通信接口:数字存储示波器可以很方便的将存储的数据送到计算机
或其他的外部设备⒔行更复杂的数据运算和分析处理。还可以通过GPIB接口与
计算机一起构成自动测试系统。 2.4数字存储示波器的主要技术指标 数字存储示波器与波形显示有关技术指标与模拟示波器相似⑾旅娼鎏致塾
波形存储部分有关的主要技术指标。 2.4.1最高取样速率 最高取样速率指单位时间内的取样的次数⒁渤剖字化速率⒂妹棵胫油瓿傻AD转换的最高次数来衡量。常以频率来表示⑷⊙速率越高⒎从σ瞧鞑蹲礁叩2章 数字存储示波器的基本原理 
 -7- 频或快速信号的能力愈强。取样速率主要由AD转换速率来决定。数字存储示波器
的测量时刻的实时取样速率可根据被测信号所设定的扫描时间因数. 2.4.2存储带宽 存储带宽与取样速率密切相关じ据取样定理と绻取样速率大于或等于二倍的信号频率け憧芍叵衷信号。实际上の保证所显示波形的分辨率ね往要
求增加更多的取样点ひ话闳N=4-10倍或更多ぜ创娲⒋宽。 2.3.3分辨率 分辨率指示示波器能分辨的最小电压增量ぜ戳炕的最小单元。它包括垂直 
分辨率和水平分辨率。垂直分辨率与AD转换的分辨率相对应こＲ云聊幻扛竦姆
级数或百分数来表示。水平分辨率由取样速率和存储器的容量决定こＲ云聊幻
格含多少个取样点或用百分数来表示。取样速率决定了两个点之间的时间间隔
存储容量决定了一屏内包含的点数。一般示波管屏幕上的坐标刻度为8*10div
如果采用8位的AD转换器ぴ虼怪狈直媛时硎疚32级/divせ蛴冒俜质来表示为
1/256=0.39%ト绻采用容量为1k的RAMぴ蛩平分辨率为1024/10=100点/div。 2.4.4存储容量 存储容量又称记录长度に由采集存储器最大存储容量来表示こＲ宰治单
位。数字存储器常采用2565121K等容量的高速半导体存储器。 2.4.5读出速度 读出速度是指将数据从存储器中读出的速度こＳ谩笆奔/div”来表示て渲歇な奔湮屏幕上每格内对应的存储容量乘以读脉冲周期。使用中应根据显示器
记录装置或打印机等对速度的要求进行选择。 2.5数字信号的采集与存储 在数字存储示波器中つＪ转换电路在给定采样时钟的节拍下把输入模拟信
号转换为离散的数据值A/D转换器始终以最高取样率进行工作。ADC参数的选
取需要考虑多方面的因素ADC的取样频率取决于待测信号的频率范围せ蛘呤净北理工大学轻工学院 
 -8- 波器对扫描速度的要求ざADC的编码位数与垂直分辨率相关。根据这两个条件
选择合适的ADC芯片。 
波形重组是根据所用的显示器将采集到的离散数字信号进行调整之后＝其
在显示器的垂直方向和水平方向重新定位４娲⒌讲ㄐ未娲⑵髦小 
数字信号保存到存储器中RAM的位数须根据ADC的位数来选择Ｈ绻ADC
为8位输出Ｄ敲RAM也应该为8位３过8位则可以选用16位的RAM。RAM的
容量取决于每次采样的采样点数Ｕ夂退平分辨率相关。写入RAM的数据来自于
ADC６脸鲋后再经过单片机处理进行波形重组Ｈ缓笤谝壕显示器上进行显示。
在本设计中Ｓ布设计分为两个部分―――波形显示电路和频率显示电路
波形显示电路中Ｊ紫仁褂A/D转换器６允淙氲哪Ｄ庑藕攀字化Ｒ允沟テ机
能够识别Ｍ时；挂使用单片机控制A/D转换器。对于A/D转换器采样的数据
经过转换之后单片机可以直接读取６杂诙寥〉氖据Ｍü单片机输出＞过显
示器Ｖ苯酉允静ㄐ巍 
频率显示电路中＠用外围电路对信号进行采集Ｗ换为高低电平之后５
片机读取Ｊ涑觥５3章 系统硬件电路的设计  -9- 第3章 系统硬件电路的设计 3.1 STC15W4K60S4系列单片机 STC15W4K60S4系列单片机是STC生产的单时钟、机器周期的单片机な强
电压、高速、高可靠、低功耗、超强抗干扰的新一代8051单片机げ捎STC第
九代加密技术。加密性超强指令代码完全兼容传统8051さ速度快8―12倍。
内部集成高精度R/C时钟,5MHz―35MHz宽范围可设置た沙沟资〉敉獠堪汗蟮
晶振和外部复位电路6路CCP/PWM/PCA,8路高速10位A/D转换,内置4k字节
大容量SRAM,4组独立的高速异步串行通信端口,1组高速同步串行通信端口SPI
针对多串行通信\电机控制强干扰场合。内置比较器すδ芨强大。如图3.1。 
 
图3.1 STC15W4K6054原理图 3.2 LCD12864 表3.1总体参数表 
管脚
号 
管脚名
称 
电平 管脚功能描述 
1 VSS 0V 电源地 
2 VCC 3.0~+5V 电源正 华北理工大学轻工学院 
 -10- 3
 V0 - 对比度Я炼泉ǖ髡 
4 RS(CS H/L 
RS=“H”,表示DB7――DB0为显示数据 
RS=“L”,表示DB7――DB0为显示指令数据 
5 
R/W(SI
D) 
H/L 
R/W=“H”,E=“H”,数据被读到DB7――DB0 
R/W=“L”,E=“H→L”, DB7――DB0的数据被写到I
R或DR 
6 
E(SCL
K) 
H/L 使能信号 
7 DB0 H/L 三态数据线 
8 DB1 H/L 三态数据线 
9 DB2 H/L 三态数据线 
10 DB3 H/L 三态数据线 
11 DB4 H/L 三态数据线 
12 DB5 H/L 三态数据线 
13 DB6 H/L 三态数据线 
14 DB7 H/L 三态数据线 
15 PSB H/L H8位或4位并口方式L串口方式 
16 NC - 空脚 
17 /RESET H/L 复位端┑偷缙接行 
18 VOUT - LCD驱动电压输出端 
19 A VDD 背光源正端+5V 
20 K VSS 背光源负端 
 
12864是128*64点阵液晶模块的点阵数简称。 
*注释1如在实际应用中仅使用并口通讯模式┛山PSB接固定高电平。 
*注释2模块内部接有上电复位电路┮虼嗽诓恍枰经常复位的场合可将该端 
   悬空。 
*注释3如背光和模块共用一个电源┛梢越模块上的JA、JK用焊锡短接。 
LCD12806电路原理图如图3.2。 
 第3章 系统硬件电路的设计  -11-  图3.2 LCD12864原理图 3.3硬件系统设计 我们要先把波形显示出来Ｒ蛭波形有大有小Ｊ紫任颐且对它进行一个调
理。因为调理包括把大信号变成小信号０研⌒藕疟涑纱笮藕弄０研藕盘Ц擢０
波形调到适合单片机ADC采样２裳之后将所得到的值写到RAM中Ｍü单片机
进行计算将波形在液晶屏幕上显示出来Ａ硗馕颐切枰对输入信号进行处理提取
出信号的特性０括频率、电压值、分析信号的波形。所以示波器我们大概可以
分为两个部分Ｒ徊糠治显示信号的波形Ｒ徊糠治提取信号的特征。例如の
们在计算电压值的时候Ｎ颐强梢酝ü波形进行计算。 
电压值可以通过采样值得出２裳值可以通过求VPP进行计算２裳得到许
多的点Ｎ颐墙这些点的最大值和最小值求出来就等于求出了VPP,频率可通过
对所得的图形进行整形Ｕ形成一个方波Ｎ颐嵌运在一定的周期里面进行计数
就可以得到频率；蛘呶颐堑玫剿的周期T８据F=T/1可求得频率。所以信号
需要先对它进行整形Ｈ缓蠖运进行计数。 
信号的流动是经过许多步骤进行流动的Ｊ紫仁切藕诺氖淙氇Ｐ藕攀淙虢来
我们先要进行耦合？次颐鞘侵蝗∷的直流成分还是交流成分；蛘咚凳且去掉
它的直流成分还是交流成分Ｆ渲谢拱括输入阻抗的部分Ｊ淙胱杩挂大于100K
用示波器测量电路中两个点之间的波形Ｊ导噬鲜墙示波器并联到电路中Ｎ了
测量到的精度Ｒ求示波器对所测量电路的影响尽可能的小８据
R=R1*R2/(R1+R2),所以需要示波器的电阻无穷大才能减小对电路的影响,在理想
状态下我们可以将100K看作无穷大Ｎ彝ü四个47K的电阻串联得到这个阻抗
耦合是通过电容隔直通交的原理来实现Ｓ杉痰缙骺刂啤５奔痰缙餮≡裣旅娴氖
候直流就可以通过＝交流隔掉了。通过电阻分压 继电器可以选择信号的链接；北理工大学轻工学院 
 -12- 跟随器提高阻抗将驱动的能力加强＝信号增强。放大器可以选择放大两倍或者
放大十倍U4d是一个加法器Ｐ藕攀怯懈貉沟牡是单片机仅能测正压Ｎ颐窍
到的办法就是将信号或者可接收的图像进行抬高Ｔ谝桓稣弦坐标系中抬高到
2.5V 。如图3.3。  
 图3.3波形抬高示意图 
 
TL431可以产生一个2.5V的基准源＜由2.5之后进行跟随Ｔ俳行一下
滤波Ｈ缓笏偷降テ机内部ADC中去Ｕ馐且桓銮拔赖缏藩５テ机信号为0V―
5V５贝笥5V单片机接收就有可能烧毁Ｋ以最好做一个保护装置＝电压限
制在5V以内８据二极管的单向导电性Ｇ懊媸歉随器通过电容去掉直流信号
留下交流信号Ｓ滞ü过零比较器可以产生一个方波Ｍü测量两个相邻波峰电
压或者波形周期就可以得到频率。第4章 系统功能的软件设计  -13- 第4章 系统功能的软件设计 4.1单片机软件开发系统 keil uVision简介 
keil uVision是美国Keil Software公司出品的51系列兼容单片机C语言软件
开发系统Ｓ牖惚嘞啾泉C语言在功能上、结构性、可读性、可维护性上有明显
的优势Ｒ蚨易学易用。用过汇编语言后再使用C来开发Ｌ寤岣加深刻。keil 
uVision软件提供丰富的库函数和功能强大的集成开发调试工具ＨWindows界
面。另外重要的一点Ｖ灰看一下编译后生成的汇编代码＞湍芴寤岬Keil C51
生成的目标代码效率非常之高６嗍语句生成的汇编代码很紧凑Ｈ菀桌斫狻Ｔ
开发大型软件时更能体现高级语言的优势。 
C51工具包的整体结构Ｆ渲uVision是C51 for Windows的集成开发环境
可以完成编辑、编译、连接、调试、仿真等整个开发流程。开发人员可用IDE本
身或其它编辑器编辑C或汇编源文件。然后分别由C51及A5l编译器编译生成目标
文件。目标文件可由LIB51创建生成库文件Ｒ部梢杂肟馕募一起经L51连接定位
生成绝对目标文件。ABS文件由OH51转换成标准的Hex文件Ｒ怨┑魇云dScope51
或tScope51使用进行源代码级调试Ｒ部捎煞抡嫫魇褂弥苯佣阅勘臧褰行调试
也可以直接写入程序存储器如EPROM中。 4.2主程序设计及流程图 4.2.1 数字存储示波器系统流程图 仪器是一个以硬件为基础的、软硬件紧密结合的系统Ｈ砑是智能仪器的灵
魂。示波器软件采用C语言来编写Ｍ瓿啥匀嘶界面、系统控制、系统硬件、波
形参数分析等的控制。 
系统的软件设计主要是单片机程序设计６杂诘テ机控制程序２捎C语言
来编写。输入信号频率计算A/D转换Ｊ据存储＜盘扫描Ｒ壕显示等。整
个系统由键盘驱动２煌的按键对应不同的事件处理。图4.1。 华北理工大学轻工学院 
 -14- 开始
程序初始化
i对50取余是否为0
计算频率值
采样存储A/D转换值
数据处理
清屏
显示
判断是否有键按下
采
样
点
数
增
加
8
采
样
点
数
减
少
8
显
示
峰
值
显
示
峰
峰
值
显
示
有
效
值
重
新
计
算
显
示
清
屏
复
位
i++
NO
YES
NO
   YES  
图4.1 系统流程图 
标准信号发生器输入方波⑷角波⒕獬莶í⒄弦波得到的测试结果。显示
屏可以显示波形⑵德始胺度的大小数值⑼时存储示波器样机对波形的测试没
有明显的失真。 
 
 
 
 
 第5章 结论和展望  -15- 第5章 结论和展望 5.1结论 经过几个月的努力Ｖ沼谕瓿闪烁锰饽康纳杓篇Ｗ芙峒父鲈吕吹墓ぷ鳘Ｖ饕
有以下几个方面 
(1).综述了现阶段数字存储示波器技术及产品的国内外发展状况６允字存
储示波器的原理、工作方式、显示方式等的基本概念及技术发展进行了介绍。 
(2).针对设计的任务和要求Ｈ范了存储示波器波形采样和数据处理及波形
重组的硬件和软件方案。 
(3).对整机各部分关键电路进行相关理论分析、计算和设计。 
(4).本系统由单片机主控ICL7662进行模数转换Ｓ62256来实现波形的
存储Ｍü软件直接对转换后的数字信号进行存储２⒍恋降テ机中完成波形重
组任务之后显示到液晶屏上Ｉ柚昧16个按键６圆裳速率Ｏ允镜缪估嘈偷
方面配合单片机进行了控制。 
(5).完成了样机的制作与调试ヂ凼隽艘瞧鞯牟馐苑椒íＭ瓿墒据测试及测
试结果分析。 5.2展望 由于时间和条件的限制１鞠低骋泊嬖谝恍┎蛔阒处？稍诮窈蟮墓ぷ髦懈
进。 
(1).由于STC15W4K60S4的输入电压范围为0--5V５ゼ性输入。这样就限
制了设计的输入Ｔ诘缏飞杓浦心芗由闲藕欧糯蟮缏泛退ゼ醯缏藩Ｔ蚩梢栽龃笮
号的测量范围。 
(2).ARM等高性能、低成本微处理器的出现Ｒ约扒度胧Linux、WinCE等
操作系统的发展Ｎ高性能智能化电子测试仪器的设计提供了良好的平台。如能
将本系统中的主控芯片单片机换成ARMＴ蚋孟低车哪芰将大大提高 
(3).对于采集到的数字信号的处理可以采用DSP高速数字信号处理芯片Ｕ
样更能显示出系统的实时性和灵敏性。 
(4).设计中的显示屏为LCD12864Ｕ庋示波器的指标４怪笨潭取⒋怪狈
辨率、水平刻度、水平分辨率就受到了限制Ｋ以设计的显示可以换成更好的显
示器。 致谢  -16- 致  谢 通过这次毕业设计很好的检验了我在大学四年中所学理论知识的掌握程度
锻炼了我的实际动手能力Ｎ以后的学习、工作奠定了基础。回顾这几个月的设
计制作８惺芰级唷 
首先感谢郭慧娜老师８行荒在我的毕业设计期间对我的亲切关怀和悉心指
导。在您的指导下Ｎ已У搅诵矶嘀识；苟土读硕灾识的应用能力Ｕ庑┙使
我终生受益匪浅。在此向您致以最诚挚的敬意。 
在试验调试的过程中８行谎校在试验室及网络资料查阅方面提供的帮助。 
感谢华北理工大学轻工学院的所有老师Ｄ忝撬哪甑慕袒濯Ｈ梦页墒旖步许
多じ行徊饪丶际跤胍瞧靼嗟乃有同学Ｄ忝侨缧值芙忝冒愕陌镏Ｈ梦腋惺艿
友谊的珍贵。 
感谢所有对我论文进行了评审和答辩的老师。  参考文献  -17- 参考文献 [1] 泰克 TDS6000C 示波器获 EDN China 创新奖。测控技术2005お12 
[2] Infiniium 系列示波器。世界电子元器件2006.01 
[3] 赵红菊せ于CPLD的数字存储示波器。电子工程师2002お12 
[4] 朱正ぬ酪慵岐ご罅ν乒憧杀涑雎呒器件ぜ铀倩电一体化产品开发
中国仪器仪表1992お03 
[5] 张泽厚ぶ莒厦鳘ね跤斜。数字存储示波器在机电测试中的运用。国外
电子测量技术1997お05 
[6] Andrew Dawson。如何选择合适的波形仪器ナ字存储示波器或数字化
仪表。今日电子2006お01 
[7] 赵茂泰。简易数字存储示波器评述。电子世界2002お11 
[8] 唐海庆な字存储示波器在机电测试中的运用[J]。仪器仪表与分析监
测1998 03 
[9] 周德新ね跖舄し妒卣ぶ旌枇帧；于FPGA的数字存储示波器 中国民
航学院学报200402 
[10] 谢从珍ね踅üせ屏帷Ｊ字存储示波器噪声特性的分析 高电压技术
2004お06 
[11] 沈兰荪数据采集系统的原理和应用。北京ト嗣裼实绯霭嫔绐1995 
[12] 赵新民。智能仪器设计基础。哈尔滨工业大学出版社1999 
[13] 刘全等。携式20M数字存储示波器。电子制作2005年第4期 
[14] 王成儒び⑽蔼USB2.0 原理和工程研发。北京ス防工业出版社2004 
  
 
 
 
 
 
 
 
 
 
 附录  -18- 附录一 数字存储示波器主程序 
void DelayMs( int t ) 
{ 
 int i ; 
 while( t-- ){ 
  i = 33178 ; 
  while( i-- ) ; 
 } 
} 
void main() 
{ 
 unsigned char iloop = 0 ; 
 P0M1 = 0x00; 
 P0M0 = 0xff; 
 P3M1 = 0x00; 
 P3M0 = 0x00; 
 
 P1M1 = P1M1 | 0x48 ; 
 P1M0 = P1M0 & 0xb7 ; 
 
 LCD_Init(); 
 PCA_Init(); 
 Uart1_init() ; 
 Timer0_init() ; 
 LCD_RAM_Init(); 
 
 LCD_RAM_Write( 0xf8 ); 
 while( 1 ){ 
  iloop++ ; 
 
  if( STOP_RUN == 1 ){附录  -19-  
   ADC_Length = 0 ; 
   ET0 = 1 ; 
   while( ADC_Length < 512 ){ 
    //SwitchWork(); 
   } 
   ET0 = 0 ; 
   WorkOutSample(); 
   LCD_RAM_Write( 0x21 ); 
 
   if( iloop == 5 ) { 
    LCD_RAM_Write( 0xde ); 
    iloop = 0 ;  
   } 
  } 
  else { 
   ET0 = 0 ; 
   if( iloop == 50 ) { 
    LCD_RAM_Write( 0xde ); 
    iloop = 0 ;  
   } 
  } 
  SwitchWork(); 
 
 }  
} 
 
#include "LCD12864.h" 
 
#define lcm P0  
sbit p_csl = P3^7; 
sbit p_cs2 = P3^6; 
sbit p_rs  = P1^2; 
sbit p_rw  = P1^1; 附录  -20- sbit p_e   = P1^0; 
 
xdata unsigned char LCD_RAM[1024] = { 0 } ; 
code char PointCode[8] = { 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 
0x80 } ; 
 
void delay(unsigned int k) ; 
void wcode(unsigned char c,unsigned char csl,unsigned char csr) ; 
void wdata(unsigned char c,unsigned char csl,unsigned char csr) ; 
void set_startline(unsigned char i) ; 
void set_xy(unsigned char x,unsigned char y) ; 
void dison_off(unsigned char o) ; 
void lw(unsigned char x,unsigned char y,unsigned char dd) ; 
 
void LCD_RAM_Point( unsigned char x, unsigned char y ) ; 
void LCD_RAM_Byte( unsigned char x, unsigned char y , unsigned char dat ) ; 
void LCD_RAM_Char5_8( unsigned char x, unsigned char y , unsigned char 
*p ) ; 
void LCD_RAM_Init( void ) ; 
 
unsigned char LCD_RAM_F( unsigned char x , unsigned char y , unsigned short 
f ) ; 
unsigned char LCD_RAM_V( unsigned char x , unsigned char y , unsigned char 
v )  ; 
 
unsigned char LCD_RAM_AC_DC( unsigned char x , unsigned char y , unsigned 
char AC_DC ) ; 
unsigned char LCD_RAM_STOP_RUN( unsigned char x , unsigned char y , 
unsigned char STOP_RUN ) ; 
 
//延时 
void delay(unsigned int k) 
{      
 k = k*12; 附录  -21-  while(k--); 
} 
 
//写指令到LCM 
void wcode(unsigned char c,unsigned char csl,unsigned char csr) 
{  
 p_csl=csl; 
    p_cs2=csr; 
    p_rs=0; 
    p_rw=0; 
    lcm=c;//将变量C赋予LCM 
    p_e=1; 
 delay(1); 
    p_e=0; 
} 
void wdata(unsigned char c,unsigned char csl,unsigned char csr) 
{ p_csl=csl; 
    p_cs2=csr; 
    p_rs=1; 
    p_rw=0; 
    lcm=c;//将变量C赋予LCM 
    p_e=1; 
    delay(1); 
 p_e=0; 
} 
 
//设定起始行 
void set_startline(unsigned char i) 
{  
 i=0xc0+i; 
    wcode(i,1,1); 
} 
//定位X方向Y方向 
void set_xy(unsigned char x,unsigned char y) 附录  -22- {  
 x=x+0x40; 
    y=y+0xb8; 
    wcode(x,1,1); 
    wcode(y,1,1); 
} 
//屏幕开启、关闭 
void dison_off(unsigned char o) 
{  
 o=o+0x3e;  //o为1为开⑽0是关 
    wcode(o,1,1); 
} 
 
//写数据到LCM 
void lw(unsigned char x,unsigned char y,unsigned char dd) 
{  
 if(y>63)return; 
    if(x<64){  
    set_xy(x,y); 
  wdata(dd,1,0); 
 } 
 else if( x>=64 && x<128){  
   set_xy(x-64,y); 
        wdata(dd,0,1); 
    } 
 else return; 
} 
 
//LCM初始化 
void LCD_Init(void) 
{  
 unsigned char x,y; 
    delay(200); 
    dison_off(0); 附录  -23-     for(y=0;y<8;y++)  
     {  
   for(x=0;x<128;x++) 
         lw(x,y,0); 
     } 
    dison_off(1); 
    set_startline(0); 
} 
void WriteAllToLCM(unsigned char Mode ) 
{ 
 // 0x00 : write all area 
 // 0x0f : write simple area 
 // 0xf0 : write data area 
  
 unsigned char i = 0, j = 0 ; 
 short k = 0 ; 
 
 switch( Mode ) 
 { 
  case 0x00:  
     for( i = 0 ; i < 128 ; i++ ){ 
      for( j = 0 ; j < 8 ; j++ ){ 
       k = 8*i + j; 
       lw( i , j , LCD_RAM[k] ) ; 
       
      } 
     } 
     break; 
  case 0x0f: 
     for( i = 0 ; i < 128 ; i++ ){ 
      for( j = 0 ; j < 7 ; j++ ){ 
       k = 8*i + j; 
       lw( i , j , LCD_RAM[k] ) ; 
      } 附录  -24-      } 
     break; 
  case 0xf0: 
     for( i = 0 ; i < 128 ; i++ ){ 
      k = 8*i + 7; 
      lw( i , 7 , LCD_RAM[k] ) ; 
     } 
     break; 
  default: break;    
 } 
} 
 
/***************** 下面的函数操作LCD_RAM *****************/ 
 
void LCD_RAM_Point( unsigned char x, unsigned char y ) 
{ 
 short offset = 0 ; 
 offset = 8 * x + y / 8 ; 
 LCD_RAM[offset] |= PointCode[y%8] ;  
} 
void LCD_RAM_Byte( unsigned char x, unsigned char y , unsigned char dat ) 
{ 
 short offset = 0 ; 
 offset  = 8 * x + y / 8 ; 
 LCD_RAM[offset] = ( dat << 1 ); 
} 
void LCD_RAM_Char5_8( unsigned char x, unsigned char y , unsigned char 
*p ) 
{ 
 LCD_RAM_Byte( x , y , *p ) ; 
 p++ ; x++ ; 
 LCD_RAM_Byte( x , y , *p ) ; 
 p++ ; x++ ; 
 LCD_RAM_Byte( x , y , *p ) ; 附录  -25-  p++ ; x++ ; 
 LCD_RAM_Byte( x , y , *p ) ; 
 p++ ; x++ ; 
 LCD_RAM_Byte( x , y , *p ) ;    
} 
 
//绘制边框  
void LCD_RAM_Init( void ) 
{ 
 unsigned char i ; 
 for( i = 0 ; i < 128 ; i++ ){ 
  LCD_RAM_Point( i , 0 )  ; 
  LCD_RAM_Point( i , 27 ) ; 
  LCD_RAM_Point( i , 55 ) ; 
 } 
 
 for( i = 1 ; i < 55 ; i++ ){ 
  LCD_RAM_Point( 0 , i ) ; 
  LCD_RAM_Point( 63 , i ) ; 
  LCD_RAM_Point( 127 , i ) ;  
 } 
} 
unsigned char LCD_RAM_F( unsigned char x , unsigned char y , unsigned short 
f ) 
{ 
 unsigned char dat, add , zero_flag = 0 ; 
 add = x ; 
 LCD_RAM_Char5_8(add, y , ASCII[38] ); // F 
 add += 6 ; 
 LCD_RAM_Char5_8(add, y , ASCII[29] ); // = 
 add += 6 ; 
  
 f = f % 10000 ; 
 dat = f / 1000 ; 附录  -26-  if( dat != 0 ){ 
  LCD_RAM_Char5_8(add, y , num5_8[dat] ); 
  add += 6 ; 
  zero_flag = 1 ; 
 } 
  
 dat = ( f % 1000 ) / 100 ; 
 if( dat != 0 || zero_flag ){ 
  LCD_RAM_Char5_8(add, y , num5_8[dat] ); 
  add += 6 ; 
  zero_flag = 1 ;  
 } 
 
 dat = ( f % 100 ) / 10 ; 
 if( dat != 0 || zero_flag ){ 
  LCD_RAM_Char5_8(add, y , num5_8[dat] ); 
  add += 6 ;  
 } 
 
 dat = f % 10 ;  
 LCD_RAM_Char5_8(add, y , num5_8[dat] ); 
 
 add += 6 ; 
 LCD_RAM_Char5_8(add, y , ASCII[40] ); // H 
 
 add += 6 ; 
 LCD_RAM_Char5_8(add, y , ASCII[90] ); // z 
 
 add += 6 ; 
 return add ;   
} 
 
unsigned char LCD_RAM_V( unsigned char x , unsigned char y , unsigned char 
v ) 附录  -27- { 
 unsigned char dat, add; 
 
 add = x ; 
 LCD_RAM_Char5_8(add, y , ASCII[53] ); // U 
 
 add += 6 ; 
 LCD_RAM_Char5_8(add, y , ASCII[29] ); // = 
 
 v = v % 100 ; 
 add += 6 ; 
 dat =  v / 10 ; 
 LCD_RAM_Char5_8(add, y , num5_8[dat] ); 
 
 add += 6 ; 
 LCD_RAM_Char5_8(add, y , ASCII[14] ); // . 
 
 add += 6 ; 
 dat = v % 10 ;  
 LCD_RAM_Char5_8(add, y , num5_8[dat] ); 
 
 add += 6 ; 
 LCD_RAM_Char5_8(add, y , ASCII[54] ); // V 
 
 add += 6 ;  
 return add ; 
} 
 
void LCD_RAM_Clean( unsigned char Mode ) 
{ 
 // 0x00 : clean all area 
 // 0x0f : clean simple area 
 // 0xf0 : clean data area  
 unsigned short i ; 附录  -28-  switch ( Mode ){ 
  case 0x00 : 
   for( i = 0 ; i < 1024 ; i++ ) 
    LCD_RAM[i] = 0x00 ; 
   break; 
  case 0x0f : 
   for( i = 0 ; i < 1024 ; i++ ){ 
    if( ((i + 1) % 8) == 0 ) continue ; 
    LCD_RAM[i] = 0x00 ; 
   } 
   break ; 
  case 0xf0 : 
   for( i = 7 ; i < 1024 ; i = i + 8 ){ 
    LCD_RAM[i] = 0x00 ; 
   } 
   break ;  
  default : 
   break ; 
 } 
} 
 
unsigned char LCD_RAM_STOP_RUN( unsigned char x , unsigned char y , 
unsigned char STOP_RUN ) 
{ 
 // 0 : STOP 
 // 1 : RUN 
 
 if( STOP_RUN == 0x00 ){ 
  LCD_RAM_Char5_8(x, y, ASCII[51] ); // S 
  x += 6 ; 
  LCD_RAM_Char5_8(x, y, ASCII[52] ); // T 
  x += 6 ; 
  LCD_RAM_Char5_8(x, y, ASCII[47] ); // O 
  x += 6 ; 附录  -29-   LCD_RAM_Char5_8(x, y, ASCII[48] ); // P 
 } 
 else { 
  LCD_RAM_Char5_8(x, y, ASCII[0] );  //  
  x += 6 ; 
  LCD_RAM_Char5_8(x, y, ASCII[50] ); // R 
  x += 6 ; 
  LCD_RAM_Char5_8(x, y, ASCII[53] ); // U 
  x += 6 ; 
  LCD_RAM_Char5_8(x, y, ASCII[46] ); // N  
 } 
 
 return (x+6 ) ; 
} 
 
unsigned char LCD_RAM_AC_DC( unsigned char x , unsigned char y , unsigned 
char AC_DC ) 
{ 
 // 0 : AC 
 // 1 : DC 
 
 if( AC_DC == 0x00 ){ 
  LCD_RAM_Char5_8(x, y, ASCII[33] );  
 } 
 else { 
  LCD_RAM_Char5_8(x, y, ASCII[36] );  
 } 
 x += 6 ; 
 LCD_RAM_Char5_8(x, y, ASCII[35] ); 
 
 return (x+6 ) ; 
} 
 
void LCD_RAM_X( unsigned char x ) 附录  -30- { 
 unsigned char i ; 
 for( i = 0 ; i < 56 ; i=i+2 ){ 
  LCD_RAM_Point( x , i ) ;  
 } 
} 
 
void LCD_RAM_Y( unsigned char y ) 
{ 
 unsigned char i ; 
 for( i = 0 ; i < 128 ; i=i+2  ){ 
  LCD_RAM_Point( i , y ) ;  
 } 
} 
 
void LCD_RAM_Simple( unsigned char *dat ) 
{ 
 unsigned char i ; 
 for( i = 0 ; i < 128 ; i++ ){ 
  LCD_RAM_Point( i , *dat ) ; 
  dat++ ; 
 } 
} 
 
void LCD_RAM_Write( unsigned char Mode ) 
{ 
 if( Mode & 0x21 )  LCD_RAM_Clean( 0x0f ); 
 if( Mode & 0xde )  LCD_RAM_Clean( 0xf0 ); 
 LCD_RAM_Init( ) ;     // Write LCD_Init 
 
 if( Mode & 0x01 ){  
  LCD_RAM_Simple( Simple_RAM ) ; // Write Sample  
 } 
 if( Mode & 0x02 ){     // Write GV 附录  -31-   
 } 
 if( Mode & 0x04 ){     // Write GT 
  //  
 } 
 if( Mode & 0x08 ){     // Write F 
  LCD_RAM_F( 0  , 56 , PCA_work() ) ; 
 } 
 if( Mode & 0x10 ){     // Write V  
  LCD_RAM_V( 52 , 56 , V );  
 } 
 if( Mode & 0x20 ){     // Write XY 
  LCD_RAM_X( X1 ); 
  LCD_RAM_X( X2 ); 
  
  LCD_RAM_Y( Y1 ); 
  LCD_RAM_Y( Y2 ); 
 } 
 if( Mode & 0x40 ){  // write RUN_STOP 
  LCD_RAM_STOP_RUN( 105 , 56 ,STOP_RUN ); 
 } 
 if( Mode & 0x80 ){  // write AC_DC 
  LCD_RAM_AC_DC( 91 , 56 , AC_DC );  
 } 
 
 WriteAllToLCM( 0x00 ) ; 
} 
 
#include "STC15_ADC.h" 
#include "intrins.h" 
 
#define ADC_POWER 0x80 
#define ADC_FLAG 0x10 
#define ADC_START 0x08 附录  -32- #define ADC_SPEEDLL 0x00 
#define ADC_SPEEDL 0x20 
#define ADC_SPEEDH 0x40 
#define ADC_SPEEDHH 0x60 
 
unsigned char Get_ADC_Result( unsigned char ch) 
{ 
 ADC_CONTR = ADC_POWER|ADC_SPEEDHH|ch|ADC_START; 
 nop_();nop_();nop_();nop_(); 
 while(!(ADC_CONTR&ADC_FLAG)); 
 ADC_CONTR &=~ADC_FLAG; 
 return ADC_RES;  
}  